
LAB 1 — Builder + Factory
Controlling Configuration Explosion
Problem
Complex object creation with:
* Many optional fields
* Cross-cutting validation
* Multiple output variants
Legacy Smell
* Telescoping constructors
* String flags
* Conditional creation logic
Goal
* Builder controls configuration
* Factory controls representation
Expected Architecture

```
Report
└── ReportBuilder
└── ReportRenderer (interface)
    ├── PdfRenderer
    ├── HtmlRenderer
    └── ExcelRenderer
└── ReportRendererFactory

```

Starter Code (LAB 1)

```
public class ReportRequest {
    public String type;
    public String format;
    public boolean charts;
    public boolean footer;
}

```

Task
* Introduce `Report.Builder`
* Introduce `ReportRendererFactory`
* Eliminate conditional logic from client code
* Report must be immutable
LAB 2 — Abstract Factory
Enforcing Compatibility Across Families
Problem
Multiple infrastructure “families”:
* Cloud providers
* Databases
* Messaging systems
Mixing implementations causes runtime failures.
Goal
Guarantee compatible families.
Expected Architecture

```
InfrastructureFactory
├── AwsInfrastructureFactory
└── AzureInfrastructureFactory

Creates:
├── DatabaseClient
├── MessageBus
└── ObjectStorage

```

Starter Interface

```
public interface InfrastructureFactory {
    DatabaseClient database();
    MessageBus messageBus();
    ObjectStorage storage();
}

```

Task
* No `new` in application code
* Swapping cloud = swapping factory
* Enforce family consistency
LAB 3 — Prototype
Eliminating Expensive Instantiation
Problem
Objects take seconds to initialise:
* Parsing
* Network calls
* Asset loading
Goal
* Create baseline prototypes once
* Clone cheaply
* Ensure deep copies
Expected Architecture

```
ServiceTemplate (Prototype)
└── clone()
└── customise(...)

```

Starter Code

```
public class ServiceTemplate {
    private Map<String, String> config;
}

```

Task
* Implement deep cloning
* Demonstrate prototype registry
* Show performance improvement
LAB 4 — Removing Singleton with DI (Advanced)
Decoupling Lifecycle from Usage
Problem
Global state:
* Hard to test
* Hidden dependencies
* Order-dependent bugs
Goal
* Remove Singleton
* Externalise lifecycle
* Preserve single-instance semantics via DI
Starter Code

```
public class MetricsClient {
    public void record(String metric) {}
}

```

Task
* Convert Singleton to normal class
* Introduce factory or container configuration
* Demonstrate testability with mock injection
PART 2 — GITHUB REPOSITORY STRUCTURE (CLEAN & TEACHABLE)
Use this exact layout:

```
creational-patterns-labs/
├── lab-01-builder-factory/
│   ├── README.md
│   └── src/main/java/...
├── lab-02-abstract-factory/
│   ├── README.md
│   └── src/main/java/...
├── lab-03-prototype/
│   ├── README.md
│   └── src/main/java/...
├── lab-04-di-vs-singleton/
│   ├── README.md
│   └── src/main/java/...
└── README.md

```
